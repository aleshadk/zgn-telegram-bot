import { addHours, formatISO } from 'date-fns';

import { IRehearsal, IRehearsalSaveModel } from '../../DAL/Rehearsal/rehearsal.model';
import { RehearsalRepository } from '../../DAL/Rehearsal/rehearsal.repository';
import { UserRepository } from '../../DAL/User/user.repository';
import { formatRehearsalDateWithDuration } from '../../Services/DateUtils';

interface IHandlerResult {
    message: string;
    rehearsal: IRehearsal | null;
}

export class BookRehearsalHandler {
    private readonly rehearsalRepository = new RehearsalRepository;;
    private readonly userRepository = new UserRepository;;


    public async handle(data: {userTelegramId: number, rehearsalDate: string, startTime: string, duration: string}): Promise<IHandlerResult> {
        const user = await this.userRepository.getUser({telegramId: data.userTelegramId});
        if (!user) {
            return {
                message: '–¢–µ–±—è –Ω–µ—Ç –≤ –Ω–∞—à–µ–π –±–∞–∑–µ, –ø–æ–ø—Ä–æ–±—É–π –Ω–∞–ø–∏—Å–∞—Ç—å /start –∏ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è',
                rehearsal: null,
            };
        }

        const startTime = this.calculateStartTime(data.rehearsalDate, data.startTime);
        const endTime = this.calculateEndTime(startTime, data.duration);

        const hasFreeSlot = await this.hasFreeSlot(startTime, endTime);

        if (!hasFreeSlot) {
            return {
                message: `–†–µ–ø–µ—Ç–∏—Ü–∏—è –Ω–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∞: —ç—Ç–æ—Ç —Å–ª–æ—Ç –∑–∞–Ω—è—Ç`,
                rehearsal: null
            }
        }

        const saveModel: IRehearsalSaveModel = {
            createdBy: user,
            endTime,
            startTime,
            isConfirmed: false
        }

        const rehearsal = await this.rehearsalRepository.createRehearsal(saveModel);
        return {
            rehearsal,
            message: `–£—Å–ø–µ—à–Ω—ã–π —É—Å–ø–µ—Ö, –∂–¥—ë–º –æ—Ç –∞–¥–º–∏–Ω–æ–≤ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Ä–µ–ø–µ—Ç–∏—Ü–∏–∏ ${formatRehearsalDateWithDuration(rehearsal.startTime, rehearsal.endTime)} ü§ò`
        };
    }

    private calculateStartTime(rehearsalDate: string, rehearsalStartTime: string): Date {
        const startTime = new Date(parseInt(rehearsalDate));
        const [startHour, startMinute] = rehearsalStartTime.split(':');
        startTime.setHours(parseInt(startHour));
        startTime.setMinutes(parseInt(startMinute));

        return startTime;
    }

    private calculateEndTime(startTime: Date, duration: string): Date {
        return addHours(startTime, parseInt(duration));
    }

    private async hasFreeSlot(startTime: Date, endTime: Date): Promise<boolean> {
        const rehearsals = await this.rehearsalRepository.getRehearsalsWhereStartTimeBetween(startTime, endTime);
        return rehearsals.length === 0;
    }
}