import { addHours, formatISO } from 'date-fns';
import { RehearsalRepository } from '../../DAL/Rehearsal/rehearsal.repository';
import { UserRepository } from '../../DAL/User/user.repository';
import { IRehearsalSaveModel } from '../../DAL/Rehearsal/rehearsal.model';

interface IHandlerResult {
    success: boolean;
    message: string;
}

export class BookRehearsalHandler {
    private readonly rehearsalRepository = new RehearsalRepository;;
    private readonly userRepository = new UserRepository;;


    public async handle(data: {userTelegramId: number, rehearsalDate: string, startTime: string, duration: string}): Promise<IHandlerResult> {
        const user = await this.userRepository.getUser({telegramId: data.userTelegramId});
        if (!user) {
            return {success: false, message: '–¢–µ–±—è –Ω–µ—Ç –≤ –Ω–∞—à–µ–π –±–∞–∑–µ, –ø–æ–ø—Ä–æ–±—É–π –Ω–∞–ø–∏—Å–∞—Ç—å /start –∏ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è'};
        }

        const startTime = this.calculateStartTime(data.rehearsalDate, data.startTime);
        const endTime = this.calculateEndTime(startTime, data.duration);

        const hasFreeSlot = await this.hasFreeSlot(startTime, endTime);

        if (!hasFreeSlot) {
            return {
                success: false,
                message: `–†–µ–ø–µ—Ç–∏—Ü–∏—è –Ω–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∞: —ç—Ç–æ—Ç —Å–ª–æ—Ç –∑–∞–Ω—è—Ç`
            }
        }

        const saveModel: IRehearsalSaveModel = {
            createdBy: user,
            endTime,
            startTime,
            isConfirmed: false
        }

        await this.rehearsalRepository.createRehearsal(saveModel);
        return {success: true, message: `–£—Å–ø–µ—à–Ω—ã–π —É—Å–ø–µ—Ö, —Ä–µ–ø–µ—Ç–∏—Ü–∏—è —Å ${formatISO(startTime)} –¥–æ ${formatISO(endTime)} –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∞ ü§ò`};
    }

    private calculateStartTime(rehearsalDate: string, rehearsalStartTime: string): Date {
        const startTime = new Date(parseInt(rehearsalDate));
        const [startHour, startMinute] = rehearsalStartTime.split(':');
        startTime.setHours(parseInt(startHour));
        startTime.setMinutes(parseInt(startMinute));

        return startTime;
    }

    private calculateEndTime(startTime: Date, duration: string;): Date {
        return addHours(startTime, parseInt(duration));
    }

    private async hasFreeSlot(startTime: Date, endTime: Date): Promise<boolean> {
        const rehearsals = await this.rehearsalRepository.getRehearsalsWhereStartTimeBetween(startTime, endTime);
        return rehearsals.length === 0;
    }
}